import '../../styles.css';

import type { Text } from '@voiceflow/base-types';
import { serializeToMarkdown } from '@voiceflow/slate-serializer/markdown';
import clsx from 'clsx';
import { useCallback, useEffect, useRef, useState } from 'react';
import Markdown from 'react-markdown';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import remarkGfm from 'remark-gfm';

import { FeedbackButton } from '../FeedbackButton';
import { FeedbackButtonVariant, type IFeedbackButton } from '../FeedbackButton/FeedbackButton.interface';
import { Icon } from '../Icon';
import {
  agentMessageContainer,
  aiIconModifier,
  codeBlockContainer,
  contentStyle,
  copyButton,
  embeddedContent,
  feedbackButtonContainer,
  generatedChin,
  generatedChinContent,
  lastListItem,
  lastPElement,
  markdownParagraph,
} from './AgentMessage.css';
import codeTheme from './code-theme';
import { CopyButton } from './CopyButton';

interface IAgentMessage {
  text: string | Text.SlateTextValue;
  children?: React.ReactNode;
  ai?: boolean;
  disclaimerMessage?: string;

  isLast?: boolean;
  feedback?: IFeedbackButton | undefined;
  debug?: boolean;
  textContent?: string;
}

function useStreamingContent(initialContent = '') {
  const [streamedContent, setStreamedContent] = useState(initialContent);

  const appendContent = useCallback((newText: string) => {
    setStreamedContent((prev) => prev + newText);
  }, []);

  const resetContent = useCallback(() => {
    setStreamedContent('');
  }, []);

  return { streamedContent, appendContent, resetContent };
}

export const AgentMessage: React.FC<IAgentMessage> = ({
  text,
  children,
  ai,
  disclaimerMessage = 'Generated by AI, double-check for accuracy.',
  isLast,
  feedback,
  textContent,
}) => {
  // Convert text to markdown if it's not a string
  const content = typeof text === 'string' ? text : serializeToMarkdown(text);

  const { streamedContent, appendContent, resetContent } = useStreamingContent('');
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    // Clear any ongoing interval
    if (intervalRef.current) {
      clearInterval(intervalRef.current!);
      intervalRef.current = null;
    }

    if (!content) {
      // If there's no content, just reset
      resetContent();
      return;
    }

    // Determine how much has already been streamed
    const streamedLength = streamedContent.length;

    // If the new content is longer, stream the difference
    if (content.length > streamedLength) {
      const newSegment = content.slice(streamedLength);
      let index = 0;

      intervalRef.current = setInterval(() => {
        if (index < newSegment.length) {
          appendContent(newSegment[index]);
          index++;
        } else {
          // Done streaming this new segment
          clearInterval(intervalRef.current!);
          intervalRef.current = null;
        }
      }, 10);
    } else if (content.length < streamedLength) {
      // If content somehow got shorter, reset to the new shorter content
      resetContent();
      // Then stream from scratch if needed
      if (content.length > 0) {
        let index = 0;
        intervalRef.current = setInterval(() => {
          if (index < content.length) {
            appendContent(content[index]);
            index++;
          } else {
            clearInterval(intervalRef.current!);
            intervalRef.current = null;
          }
        }, 10);
      }
    }
    // If content length is the same as streamedContent length, do nothing
    // as we've already streamed it all.
  }, [content, streamedContent, appendContent, resetContent]);

  const isCodeBlock = streamedContent.startsWith('```javascript');

  return (
    <div className={clsx(agentMessageContainer)}>
      <Markdown
        children={streamedContent}
        className={clsx('markdown', clsx(contentStyle({ isCodeBlock })))}
        remarkPlugins={[remarkGfm]}
        components={{
          code(props: any) {
            const { children, className, node, ref, ...rest } = props;
            const match = /language-(\w+)/.exec(className || '');
            return match ? (
              <span className={codeBlockContainer}>
                <CopyButton value={children} className={copyButton} />
                <SyntaxHighlighter
                  {...rest}
                  lineProps={{
                    style: { wordBreak: 'break-all', whiteSpace: 'pre-wrap', paddingLeft: 0, paddingRight: 0 },
                  }}
                  wrapLines={true}
                  wrapLongLines={true}
                  children={String(children).replace(/\n$/, '')}
                  language={match[1]}
                  style={codeTheme}
                />
              </span>
            ) : (
              <div {...rest} className={className}>
                {children}
              </div>
            );
          },
          li: ({ children, ...props }) => {
            // Only apply lastItem styling if this li is at the end of the entire streamed text
            const position = props.node?.position;
            if (position && position.end.offset === streamedContent.length - 1) {
              return (
                <li className={lastListItem} {...props}>
                  {children}
                </li>
              );
            }
            return <li {...props}>{children}</li>;
          },
          p: ({ children, ...props }) => {
            const position = props.node?.position;
            const isFirst = position && position.start.offset === 0;
            const isParagraphEnd = position && position.end.offset === streamedContent.length - 1;
            return (
              <p
                {...props}
                className={clsx(markdownParagraph({ first: isFirst }), isParagraphEnd && lastListItem, lastPElement)}
              >
                {children}
              </p>
            );
          },
        }}
      />
      {children && <div className={embeddedContent}>{children}</div>}
      {ai && (
        <div className={generatedChin}>
          <Icon svg="ai" className={aiIconModifier} />
          <span className={generatedChinContent}>{disclaimerMessage}</span>
        </div>
      )}
      {feedback && !isLast && (
        <div className={feedbackButtonContainer}>
          <FeedbackButton {...feedback} textContent={textContent} variant={FeedbackButtonVariant.PREVIOUS_RESPONSE} />
        </div>
      )}
    </div>
  );
};
